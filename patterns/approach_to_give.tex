\input{header.tex}

\newcommand{\name}{Approach To Give}

% -------------------------------
% WAS
% -------------------------------

\newcommand{\desc}{Ein Benutzer (der \sen{}) hat ein \data{} und will es mit einem \recdev{}  teilen. Es soll über Distanz vom \sendev{} auf das \recdev{} übertragen werden, sodass es anschließend auf beiden Geräten verfügbar ist.}

\newcommand{\solution}{Der Benutzer nähert (\gls{approach}) sich mit seinem Gerät (dem \sendev{}) einem entfernten Gerät (dem \recdev{}). Nähert er sich dem \recdev{} bis auf einen bestimmten räumlichen Abstand, wird das \data{} auf das \recdev{} übertragen.}

\newcommand{\category}{give}
%\newcommand{\category}{take}
%\newcommand{\category}{exchange}
%\newcommand{\category}{extend}
%\newcommand{\category}{connect}

% -------------------------------
% WIE
% -------------------------------

\newcommand{\useraction}{Der Anwender nähert sich mit einem portablen Quell-Gerät dem Ziel-Gerät bis auf eine definierte Distanz. TODO}

\newcommand{\reaction}{Beim Erreichen einer definierten Distanz zwischen Quell- und Ziel-Gerät wird visuell, akustisch oder auf eine andere Weise erkenntlich gemacht, dass sich das Quell- und Ziel-Gerät erkannt haben. Daraufhin wird ein ausgewähltes Datenobjekt vom Sender-Gerät auf das Empfänger gerät übertragen und auf dem Ziel-Gerät dargestellt. TODO}

\newcommand{\designnotes}{Die Distanz zwischen Quell- und Ziel-Gerät darf nicht zu gering definiert werden (sonst müsste man das Quell-Gerät ggf. auf das Ziel-Gerät auflegen). TODO}

% -------------------------------
% WANN
% -------------------------------

\newcommand{\validcontext}{...}

\newcommand{\simultaneously}{}
%\newcommand{\sequentially}{}

\newcommand{\online}{}
%\newcommand{\offline}{}

\newcommand{\private}{}
\newcommand{\semipublic}{}
%\newcommand{\public}{}
\newcommand{\stationary}{}
%\newcommand{\onthego}{}

%\newcommand{\leanback}{}
\newcommand{\leanforward}{}

\newcommand{\single}{}
\newcommand{\collaboration}{}
\newcommand{\facetoface}{}
%\newcommand{\sidetoside}{}
%\newcommand{\cornertocorner}{}

%\newcommand{\smalltask}{}
%\newcommand{\repeatedtask}{}
%\newcommand{\locationbased}{}
%\newcommand{\distraction}{}
%\newcommand{\urgent}{} 

\newcommand{\notvalidcontext}{...}


\newcommand{\devicetabular}{
\begin{tabular}[H]{|c|c|c|c|c|c|}
\hline 
\diagbox{von}{nach}   & Smartwatch & Smartphone & Tablet & Tabletop & Screens \\ 
\hline 
Smartwatch            &     x      &     x      &   x    &     x    &     x   \\ 
\hline 
Smartphone            &     x      &     x      &   x    &     x    &     x   \\ 
\hline 
Tablet                &     x      &     x      &   x    &     x    &     x   \\ 
\hline 
Tabletop              &            &            &        &          &         \\ 
\hline
Screens               &            &            &        &          &         \\ 
\hline 
\end{tabular} }

% -------------------------------
% WARUM
% -------------------------------

%\newcommand{\established}{}
\newcommand{\candidate}{}
\newcommand{\realizable}{}
%\newcommand{\futuristic}{}

\newcommand{\otherpatterns}{
\begin{itemize}
\item Approach To Connect
\item Approach To Extend
\item Approach To Take
\item Leave To Disconnect
\end{itemize}
}

\newcommand{\stateoftheart}{
\begin{enumerate}
\item Theoretische und praktische Ansätze zu \textit{Proxemics}, behandelt auch negative Nutzungskontexte (sog. Dark Patterns) \cite{Marquardt2015}, \cite{Marquardt2012}.
\item Kommunikation verschiedener Personen mit einem Fernseher basierend auf der Nähe \cite{Greenberg2011}.
\item Googles Proximity Beacon API auf Basis von Eddystone \cite{Eddystone2016}
\item Apples iBeacon-Standard zur Erkennung von Proximity \cite{IBeacon2016}
\end{enumerate}
}

\newcommand{\designprinciples}{}

\newcommand{\imageschemata}{}
%\newcommand{\imageSchemaVoid}{}
%\newcommand{\imageSchemaObject}{}
%\newcommand{\imageSchemaSubstance}{}
%\newcommand{\imageSchemaCenterPeriphery}{}
%\newcommand{\imageSchemaContact}{}
%\newcommand{\imageSchemaFrontBack}{}
%\newcommand{\imageSchemaLocation}{}
\newcommand{\imageSchemaNearFar}{}
%\newcommand{\imageSchemaPath}{}
\newcommand{\imageSchemaSourcePathGoal}{}
%\newcommand{\imageSchemaScale}{}
%\newcommand{\imageSchemaLeftRight}{}
\newcommand{\imageSchemaContainer}{}
%\newcommand{\imageSchemaContent}{}
%\newcommand{\imageSchemaFullEmpty}{}
\newcommand{\imageSchemaInOut}{}
%\newcommand{\imageSchemaSurface}{}
%\newcommand{\imageSchemaMerging}{}
%\newcommand{\imageSchemaSplitting}{}
%\newcommand{\imageSchemaMomentum}{}
%\newcommand{\imageSchemaSelfMotion}{}
%\newcommand{\imageSchemaBigSmall}{}
%\newcommand{\imageSchemaFastSlow}{}
%\newcommand{\imageSchemaPartWhole}{}

\newcommand{\realworld}{}
\newcommand{\realworldNaivePhysic}{}
\newcommand{\realworldBodyAwareness}{}
\newcommand{\realworldEnvironmentAwareness}{}
\newcommand{\realworldSocialAwareness}{}

\newcommand{\metaphor}{}
\newcommand{\metaphordesc}{Magnet}

% -------------------------------
% TECHNISCHES
% -------------------------------

\newcommand{\requiredTechnologies}{
Um Approach To Give auf einem Gerät (\textit{Device}) ausführen zu können, gibt es einige Voraussetzungen und Einschränkungen bezüglich der verfügbaren Technologien auf diesem Gerät. Ein Gerät ist dann für das Approach To Give Pattern verwendbar, wenn es folgende Eigenschaften aufweist:
\begin{itemize}
\item \textbf{Proximity}: Voraussetzung für die Erkennung der Approach To Give Geste ist die technische Möglichkeit, Entfernungen zu anderen Geräten messen zu können. Dazu gibt es verschiedene technische Möglichkeiten, wobei zumeist \textit{Bluetooth Low Energy} für weitere und \textit{NFC} für kurze Distanzen weit verbreitet ist.
\item \textbf{Output}: Je nachdem, welches Feedback dem User gegeben werden soll, sind visueller Output (Bildschirm) sowie Vibration und Sound denkbar, um den Status von Dateiübertragungen zu signalisieren.
\item \textbf{Connectivity}: Ziel der Approach To Give Geste ist die Dateiübertragung
zwischen zwei Geräten, die bereits über ein Ad-Hoc Netzwerk wie Bluetooth oder WiFi Direct miteinander verbunden sind. Alternativ kann auch eine Vermittlungskomponente (Server) genutzt werden, der den Datenaustausch zentral verwaltet.
\end{itemize}

Abbildung \ref{approach_hardware} fasst die benötigten Technologien modellhaft zusammen.

\begin{figure}[h]
\includegraphics[width=\textwidth]{approach_hardware.png}
\caption{Benötigte Technologien für das Approach To Give Pattern}
\label{approach_hardware}
\end{figure}
}

\newcommand{\implementation}{
\subsubsection*{Ablauf Gestenerkennung}
Bei der Geste Approach To Give handelt es sich um eine \gls{einfachegeste}, deren Erkennung nur auf einem Gerät durchgeführt werden muss. Der allgemeine Ablauf entfällt in zwei Teile (s. Abbildung \ref{gesture_detection}):
\begin{itemize}
\item Erkennen der Geste (\textit{Gesture Detection}) und
\item Überprüfen eventueller Bedingungen an die Geste (\textit{Constraint Check}).
\end{itemize}

\begin{figure}[h]
\includegraphics[width=\textwidth]{gesture_detection.png}
\caption{Allgemeiner Ablauf einer Gestenerkennung}
\label{gesture_detection}
\end{figure}
Wurde die Geste erkannt, wird ein entsprechendes \textit{GestureEvent} generiert, das an den \textit{Constraint Check} übergeben wird.

\subsubsection*{Approach Erkennung}
Zum Erkennen der Geste wird \textit{Proximity}-Hardware vorausgesetzt, die \textit{Ranging} ermöglicht, also eine kontinuierliche Suche nach Geräten in der Umgebung. Gefundene Geräte sollten sich mit einer \textit{Service-UUID} o.Ä. identifizieren, anhand derer sie als mögliche Verbindungspartner identifiziert werden können. Daraus ergeben sich folgende Events:
\begin{itemize}
\item \textbf{DEVICE\_FOUND}: Beim Ranging wurde ein entferntes Gerät gefunden.
\item \textbf{MATCH}: Ein gefundenes Gerät besitzt die korrekte Service-UUID.
\item \textbf{NO\_MATCH}: Ein gefundenes Gerät besitzt eine ungültige Service-UUID.
\item \textbf{STOP\_RANGING}: Das Ranging wurde beendet, es werden keine weiteren. 
\end{itemize}

Basierend auf diesen Events ergibt sich die Implementierung der Approach-Erkennung entsprechend Abbildung \ref{recognize_approach}. Ein Approach wird dann erkannt, wenn ein beim Ranging gefundenes Gerät die erwartete Service-UUID besitzt. Danach kann entweder nach weiteren Geräten gesucht oder die Suche beendet werden. Besitzt ein gefundenes Gerät keine gültige Service-UUID, wird so lange weiter gesucht, bis entweder ein möglicher Verbindungspartner gefunden wurde oder ein Abbruch des Ranging signalisiert wird. Wurde ein Approach erkannt, wird ein \textit{ProximityEvent} generiert, das für die Überprüfung der \textit{Constraints} im nächsten Schritt benötigt wird.

\begin{figure}[h]
\includegraphics[width=\textwidth]{approach_recognize.png}
\caption{Erkennung der Approach Geste}
\label{recognize_approach}
\end{figure}

\subsubsection*{Approach Constraint Check}
Um einzuschränken, unter welchen Bedingungen eine Annäherung als Approach To Give gewertet werden soll, wird das im vorigen Schritt generierte \textit{ProximityEvent} mit vorher gesetzten \textit{Constraint} verglichen. Abbildung \ref{check_approach_constraints} zeigt beispielhaft den Ablauf des \textit{Constraint Checks}. Es werden zwei Constraints überprüft:
\begin{itemize}
\item Ein Integer, die sog. Major-Nummer und
\item die Entfernung (\textit{Proximity}) zum erkannten Gerät.
\end{itemize}
Der erste Constraint ist angelehnt an das iBeacon-Protokoll, in dem neben einer Service-UUID (s. voriges Kapitel) zur eindeutigen Identifikation von Geräten eine Major- und Minor-Nummer gesendet werden können. Dadurch kann der Kreis möglicher Verbindungspartner weiter eingeschränkt werden. 
Im nächsten Schritt wird die gemessene Entfernung mit einem Vorgabewert verglichen. Die vier Bereiche \textit{immediate}, \textit{near}, \textit{far} und \textit{unknown} sind angelehnt an \cite{Marquardt2015} und können auch durch konkrete Entfernungswerte ersetzt werden.\\

Entsprechend dem Lebenszyklus einer Multiscreen-Applikation ist die Voraussetzung
für Approach To Give eine bestehende Verbindung zum \recdev{} (vorangegangener Connect) und die Auswahl zu übermittelnder Daten (Select) auf dem \sendev{}. Approach To Give kann mehrmals hintereinander ausgeführt werden (Sequenz von Transfers), solange kein Disconnect erfolgt ist.\\

Weitergehende Informationen zum Applikations-Lebenszyklus und den weiteren
Gestaltungsmöglichkeiten für den \textit{Transfer}, \textit{Feedbacks} etc. finden sich
auf der \developerpage.

\begin{figure}[h]
\includegraphics[width=\textwidth]{approach_check_constraints.png}
\caption{Überprüfung der Constraints für die Approach Geste}
\label{check_approach_constraints}
\end{figure}
}

% -------------------------------
% SONSTIGES
% -------------------------------

\newcommand{\authors}{Horst Schneider, Hochschule Mannheim\\
Dominick Madden, Hochschule Mannheim\\
Valentina Burjan, Hochschule Mannheim}
\newcommand{\versionhistory}{13.09.2016}
\newcommand{\dateofcreation}{15.08.2016}
\newcommand{\comments}{...}
\newcommand{\questions}{...}


% template inkludieren --------------

\input{template.tex}